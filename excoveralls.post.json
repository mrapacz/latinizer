{"repo_token":"1lDhDcHH7lyJIG1x5NsDg2Qhe1S72raDo","service_name":"excoveralls","source_files":[{"name":"lib/latinizer.ex","source":"defmodule Latinizer do\n  alias Latinizer.{\n    Transcriptions,\n    Diacritics\n  }\n\n  @moduledoc \"\"\"\n  A module allowing one to replace regional characters in strings with their\n  closest latin equivalents.\n\n  The module takes care of both transcription and removal of diacritical signs.\n  \"\"\"\n\n  @doc \"\"\"\n  Replaces regional characters in the given string with their closest latin equivalents.\n\n  Returns a string with replaced letters. If the `:only` argument is specified,\n  only the letters provided in this argument will be replaced.\n\n  ## Examples\n  Translating with no characters specified:\n\n      iex> Latinizer.latinize \"\"\n      \"\"\n\n      iex> Latinizer.latinize \"хорошо\"\n      \"horosho\"\n\n      iex> Latinizer.latinize \"gżegżółka\"\n      \"gzegzolka\"\n\n      iex> Latinizer.latinize \"Pchnij w tę łódź jeża lub ośm skrzyń fig.\"\n      \"Pchnij w te lodz jeza lub osm skrzyn fig\"\n\n      iex> Latinizer.latinize \"В начале было Слово, и Слово было у Бога, и Слово было Бог.\"\n      \"V nachale bylo Slovo i Slovo bylo u Boga i Slovo bylo Bog\"\n\n  You can pass the `:only` option to replace only the specified characters:\n\n      iex> Latinizer.latinize \"łódeczka\", only: [\"ł\"]\n      \"lódeczka\"\n\n      iex> Latinizer.latinize \"łódeczka\", only: [\"ł\", \"ó\"]\n      \"lodeczka\"\n\n      iex> Latinizer.latinize \"łódeczka\", only: [\"ł\", \"ó\", \"Ą\", \"a\"]\n      \"lodeczka\"\n\n  \"\"\"\n\n  @spec latinize(binary, list) :: binary\n  def latinize(string, opts \\\\ []) do\n    string\n    |> Transcriptions.transcribe(opts)\n    |> Diacritics.remove_diacritics(opts)\n  end\n\n  defdelegate transcribe(string, opts \\\\ []), to: Latinizer.Transcriptions\n  defdelegate remove_diacritics(string, opts \\\\ []), to: Latinizer.Diacritics\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,14,null,null,1,1,null]},{"name":"lib/latinizer/diacritics.ex","source":"defmodule Latinizer.Diacritics do\n  alias Latinizer.Helpers\n\n  @moduledoc \"\"\"\n  A module responsible for removing diacritical signs in strings.\n  \"\"\"\n\n  @doc \"\"\"\n  Removes specified diacritical signs from a given string. If no diacritics are specified,\n  all of them will be removed.\n\n  ## Examples\n  Default usage:\n      iex> Latinizer.Diacritics.remove_diacritics \"langue indo-européenne\"\n      \"langue indoeuropeenne\"\n\n      iex> Latinizer.Diacritics.remove_diacritics \"żubrówka\"\n      \"zubrowka\"\n\n  Removing only the specified diacritical signs using the `:only` keyword:\n\n      iex> Latinizer.Diacritics.remove_diacritics \"latawiec\", only: [\"ż\", \"ą\"]\n      \"latawiec\"\n\n      iex> Latinizer.Diacritics.remove_diacritics \"żubrówka\", only: [\"ż\"]\n      \"zubrówka\"\n\n      iex> Latinizer.Diacritics.remove_diacritics \"żubrówka\", only: [\"ż\", \"ą\"]\n      \"zubrówka\"\n\n  \"\"\"\n  @spec remove_diacritics(binary, list) :: binary\n  def remove_diacritics(string, opts \\\\ []) do\n    fun =\n      case Keyword.get(opts, :only) do\n        nil ->\n          &normalize/1\n\n        chars ->\n          map = get_diacritic_mapping(chars)\n          &Helpers.map_or_leave_unchanged(&1, map)\n      end\n\n    Helpers.map_string(string, fun)\n  end\n\n  defp normalize(string) do\n    case String.trim(string) do\n      \"\" ->\n        string\n\n      _any ->\n        string\n        |> String.normalize(:nfd)\n        |> String.replace(~r/\\W/u, \"\")\n    end\n  end\n\n  defp get_diacritic_mapping(chars) do\n    chars\n    |> Enum.map(fn character ->\n         case normalize(character) do\n           \"\" -> {character, character}\n           normalized -> {character, normalized}\n         end\n       end)\n    |> Enum.filter(fn {key, value} -> key != value end)\n    |> Map.new()\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,128,123,null,123,null,null,5,5,null,null,128,null,null,null,319,null,20,null,null,null,null,299,null,null,null,null,null,null,10,null,null,null,null,10,5,null,null]},{"name":"lib/latinizer/helpers.ex","source":"defmodule Latinizer.Helpers do\n  @moduledoc false\n\n  @spec map_string(binary, fun) :: binary\n  def map_string(string, fun) do\n    string\n    |> String.graphemes()\n    |> Enum.map(fun)\n    |> List.to_string()\n  end\n\n  @spec map_or_leave_unchanged(binary, map) :: binary\n  def map_or_leave_unchanged(char, map), do: Map.get(map, char, char)\nend","coverage":[null,null,null,null,null,null,null,null,149,null,null,null,362,null]},{"name":"lib/latinizer/transcriptions.ex","source":"defmodule Latinizer.Transcriptions do\n  @moduledoc \"\"\"\n  A module storing character mappings used for transcription\n  (i.e. map containing anything that's not a diacritical sign).\n  \"\"\"\n\n  alias Latinizer.Helpers\n\n  @doc \"\"\"\n  Returns all of the character mappings as a single transcription map.\n\n  ## Examples\n\n      iex> Latinizer.Transcriptions.get_map |> Enum.take(5) |> Map.new\n      %{\"ĸ\" => \"k\", \"œ\" => \"oe\", \"Ф\" => \"F\", \"ч\" => \"ch\", \"ш\" => \"sh\"}\n\n      iex> Latinizer.Transcriptions.get_map |> Map.size\n      113\n\n  \"\"\"\n  @spec get_map() :: map()\n  def get_map(),\n    do: %{\n      \"ъ\" => \"\",\n      \"ь\" => \"\",\n      \"&#039;\" => \"\",\n      \"Ь\" => \"\",\n      \"&quot;\" => \"\",\n      \"Ъ\" => \"\",\n      \"&amp;\" => \"\",\n      \"&lt;\" => \"\",\n      \"&gt;\" => \"\",\n      \"а\" => \"a\",\n      \"А\" => \"A\",\n      \"&Auml;\" => \"A\",\n      \"&auml;\" => \"ae\",\n      \"Æ\" => \"Ae\",\n      \"æ\" => \"ae\",\n      \"Ä\" => \"Ae\",\n      \"ä\" => \"ae\",\n      \"б\" => \"b\",\n      \"Б\" => \"B\",\n      \"ц\" => \"c\",\n      \"Ц\" => \"C\",\n      \"Ч\" => \"CH\",\n      \"ч\" => \"ch\",\n      \"ð\" => \"d\",\n      \"Ð\" => \"D\",\n      \"Đ\" => \"D\",\n      \"д\" => \"d\",\n      \"Д\" => \"D\",\n      \"đ\" => \"d\",\n      \"е\" => \"e\",\n      \"э\" => \"e\",\n      \"Е\" => \"E\",\n      \"Э\" => \"E\",\n      \"ф\" => \"f\",\n      \"ƒ\" => \"f\",\n      \"Ф\" => \"F\",\n      \"г\" => \"g\",\n      \"Г\" => \"G\",\n      \"ħ\" => \"h\",\n      \"Х\" => \"H\",\n      \"х\" => \"h\",\n      \"Ħ\" => \"H\",\n      \"и\" => \"i\",\n      \"ı\" => \"i\",\n      \"И\" => \"I\",\n      \"Ĳ\" => \"IJ\",\n      \"ĳ\" => \"ij\",\n      \"ый\" => \"iy\",\n      \"к\" => \"k\",\n      \"К\" => \"K\",\n      \"ĸ\" => \"k\",\n      \"л\" => \"l\",\n      \"ł\" => \"l\",\n      \"Л\" => \"L\",\n      \"Ł\" => \"L\",\n      \"ŀ\" => \"l\",\n      \"Ŀ\" => \"L\",\n      \"м\" => \"m\",\n      \"М\" => \"M\",\n      \"ŉ\" => \"n\",\n      \"ŋ\" => \"n\",\n      \"н\" => \"n\",\n      \"Н\" => \"N\",\n      \"Ŋ\" => \"N\",\n      \"Ø\" => \"O\",\n      \"о\" => \"o\",\n      \"О\" => \"O\",\n      \"ø\" => \"o\",\n      \"Œ\" => \"OE\",\n      \"Ö\" => \"Oe\",\n      \"ö\" => \"oe\",\n      \"&ouml;\" => \"oe\",\n      \"&Ouml;\" => \"Oe\",\n      \"œ\" => \"oe\",\n      \"П\" => \"P\",\n      \"п\" => \"p\",\n      \"р\" => \"r\",\n      \"Р\" => \"R\",\n      \"С\" => \"S\",\n      \"с\" => \"s\",\n      \"щ\" => \"sch\",\n      \"Щ\" => \"SCH\",\n      \"Ш\" => \"SH\",\n      \"ш\" => \"sh\",\n      \"ſ\" => \"ss\",\n      \"ß\" => \"ss\",\n      \"þ\" => \"t\",\n      \"Т\" => \"T\",\n      \"т\" => \"t\",\n      \"Þ\" => \"T\",\n      \"Ŧ\" => \"T\",\n      \"у\" => \"u\",\n      \"У\" => \"U\",\n      \"ü\" => \"ue\",\n      \"Ü\" => \"Ue\",\n      \"&Uuml;\" => \"Ue\",\n      \"&uuml;\" => \"ue\",\n      \"в\" => \"v\",\n      \"В\" => \"V\",\n      \"Й\" => \"Y\",\n      \"Ы\" => \"Y\",\n      \"й\" => \"y\",\n      \"ы\" => \"y\",\n      \"я\" => \"ya\",\n      \"Я\" => \"YA\",\n      \"Ё\" => \"YO\",\n      \"ё\" => \"yo\",\n      \"Ю\" => \"YU\",\n      \"ю\" => \"yu\",\n      \"з\" => \"z\",\n      \"З\" => \"Z\",\n      \"ж\" => \"zh\",\n      \"Ж\" => \"ZH\"\n    }\n\n  @doc \"\"\"\n  Returns a submap of the original transcription map containing only\n  the specified characters' mapping to their latin equivalents.\n\n  ## Examples\n      iex> Latinizer.Transcriptions.get_map [\"ł\"]\n      %{\"ł\" => \"l\"}\n\n      iex> Latinizer.Transcriptions.get_map [\"ł\", \"ó\", \"Ą\"]\n      %{\"ł\" => \"l\"}\n\n      iex> Latinizer.Transcriptions.get_map [\"ф\", \"Ш\", \"ö\", \"ĳ\", \"ŋ\"]\n      %{\"ö\" => \"oe\", \"ĳ\" => \"ij\", \"ŋ\" => \"n\",\n        \"Ш\" => \"SH\", \"ф\" => \"f\"}\n\n  \"\"\"\n  @spec get_map(list(binary)) :: map()\n  def get_map(chars) do\n    get_map() |> Map.take(chars)\n  end\n\n  @doc \"\"\"\n  Transcribes specified string.\n\n  ## Examples\n      iex> Latinizer.Transcriptions.transcribe \"łata\"\n      \"lata\"\n\n      iex> Latinizer.Transcriptions.transcribe \"Русский\"\n      \"Russkiy\"\n\n      iex> Latinizer.Transcriptions.transcribe \"Во многих странах мира русский язык включается в программу среднего и высшего образования как иностранный язык.\"\n      \"Vo mnogih stranah mira russkiy yazyk vklyuchaetsya v programmu srednego i vysshego obrazovaniya kak inostrannyy yazyk.\"\n\n  You can also pass the `:only` flag to transcribe only the specified characters:\n\n      iex(4)> Latinizer.Transcriptions.transcribe \"многих\", only: [\"м\", \"н\", \"о\", \"г\", \"и\", \"х\"]\n      \"mnogih\"\n\n      iex(4)> Latinizer.Transcriptions.transcribe \"многих\", only: [\"м\", \"н\", \"о\"]\n      \"mnoгих\"\n  \"\"\"\n  @spec transcribe(binary, list) :: binary\n  def transcribe(string, opts \\\\ []) do\n    character_map =\n      case Keyword.get(opts, :only) do\n        nil -> get_map()\n        chars -> get_map(chars)\n      end\n\n    string\n    |> Helpers.map_string(&Helpers.map_or_leave_unchanged(&1, character_map))\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,26,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,10,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,20,null,13,7,null,null,null,20,null,null]}],"git":{"head":{"committer_name":"","message":"[no commit message]","id":""},"branch":""}}